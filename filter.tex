\section{Filtered Stepper Calculus}

In this section, we will discuss the semantics of the \emph{Filtered Stepper
Calculus}. We first introduce the syntax of the language, then we discuss the
the dynamics of the language, and finally we discuss the statics of the
language. The static part is optional for understanding and implement the filtered
stepper calculus, but is useful as a foundation to prove meta-theory theorems
about the calculus, for example, \emph{progression} and \emph{preservation}.

% \TODO{introduction to this section}

\subsection{Syntax}

% \TODO{put syntax into a figure}
\begin{figure}[h]
  \begin{equation*}
    \begin{array}{rcl}
      \DefAct a    &\Coloneqq& \ActSkip \mid \ActStep \\
      \DefGas g    &\Coloneqq& \GasOne \mid \GasAll \\
      \DefExp e    &\Coloneqq& x \mid e(e) \mid \Lam{x}{e} \mid e + e \mid \Nat{n} \\
                   &\mid     & \Filter{f}{e} \\
                   &\mid     & \Residue{a}{g}{l}{e} \\
      \DefPat p    &\Coloneqq& x \mid p(p) \mid \Lam{x}{p} \mid p + p \mid \Nat{n} \\
                   &\mid     & \$e \\
                   &\mid     & \$v \\
      \DefFilter f &\Coloneqq& (p, a, g) \\
    \end{array}
  \end{equation*}
  \caption{Syntax of Filtered Stepper Calculus}
  \label{fig:filter-syntax}
\end{figure}

% \TODO{overview of syntax}

The syntax of filter stepper calculus (Fig.~\ref{fig:filter-syntax}) is a
extended version of untyped lambda calculus. Additionally, natural numbers and
addition are added to it for some more concrete demonstration. It introduce two
new expression to a untyped lambda calculus language, \texttt{Filter} and
\texttt{Residue}. The \texttt{Filter} expression is visible at user level,
indicating the expression surrounded by the expression is filtered by the
filter. The \texttt{Residue} expression is used internally by the stepper and is
not visible to the user. It is used to signal the \emph{residue} of a effect of
applying a filter to an expression.

A filter is a tuple of a pattern, an action, and a gas. The pattern
is a mutated of the term of untyped lambda calculus. Apart from constructs like
variables, applications, and lambdas, it also includes some new constructs, a
forall pattern \(\$e\), a value pattern \(\$v\). The action is a tag indicating
the action to be taken when the pattern matches an expression. It has two
form, \(\ActSkip\) and \(\ActStep\). The gas is another tag indicating the
live time of the effect of a filter. It has two form, \(\GasOne\) and
\(\GasAll\).

The residue expression \(\Residue{a}{g}{l}{e}\) is a expression that is used to
store the residue of the effect of a filter. It has four components, an action
\(a\), a gas \(g\), a priority \(l\), and a expression \(e\). The action and the
gas are the same as the ones in a filter. The priority is a natural number
indicating the priority of the residue.

% \fbox{\(\DefAct a\)} Action \(a\) of a filter
% \[
%   \DefAct a \Coloneqq \ActSkip \mid \ActStep
% \]

% \fbox{\(\DefGas g\)} Gas \(g\) of a filter.
% \[
%   \DefGas g \Coloneqq \GasOne \mid \GasAll
% \]

% \fbox{\(\DefExp d\)} Expression \(d\).
% \[
%   \DefExp d \Coloneqq x \mid d(d) \mid \Lam{x}{d} \mid d + d \mid \Nat{n} \mid \Filter{(p, a, g)}{d} \mid \Residue{a}{g}{l}{d}
% \]

% \fbox{\(\DefVal d\)} Value \(v\).
% \[
%   \DefVal v \Coloneqq \Lam{x}{d} \mid \Nat{n}
% \]

% \mck{I added a value thing here but we should probably actually define it as a judgement instead.}

% \mck{Maybe replace $\Residue{a}{g}{l}{\mathcal{E}}$ with $\Residue{a}{\GasAll}{l}{\mathcal{E}}$ because only $\GasAll$ is possible?}

% \fbox{\(\DefPat p\)} Pattern \(p\).
% \[
%   \DefPat p \Coloneqq \$e \mid \$v \mid x \mid p(p) \mid \Lam{x}{d} \mid p + p \mid \Nat{n}
% \]

% \mck{The $\lambda \$x. $ form actually isn't necessary because we use alpha-equivalence later.}

% \fbox{\(\DefFilter f\)} Filter \(f\).
% \[
%   \DefFilter f = (p, a, g)
% \]

%\TODO{change notation of filter to use $f$}

%\TODO{change notation for do to be more compact}

\subsection{Contextual Dynamics}

There are two main operations in our semantics, one is to \emph{skip} the
evaluation of an expression, the other is to \emph{pause} at a certain point of
evaluation. These two operations leads to two main stepping judgement in our
dynamic specifications. The \textsc{S-Step} rule specifies when do we want to
stop at a step, while the \textsc{S-Skip} rule specifies when we want to skip over
current step and proceed to next ones.

There is an extra rule in the stepping judgement. The elimination step of filter
should be always skipped. As pattern-matching against the filter statement is
not possible within current pattern definition as in
Figure.~\ref{fig:filter-syntax}, we treat them specially to make sure these
steps are hidden and is not visible to users.

\TODO{motivate the two rules}

\fbox{\(\RuleStep{e}{e'}\)} Expression \(e\) steps to expression \(e'\).
\begin{mathpar}
  \inferrule[S-Step]{
    \FInstruct{(\ActStep, \GasOne, 0)}{e}{e_i} \\
    \Decompose{e_i}{\mathcal{E}_0}{e_0} \\
    \Analyze{(\ActStep, 0)}{\mathcal{E}_0}{\mathcal{E}_1}{\ActStep} \\
    \FTrans{e_0}{e_t} \\
    \Compose{e_1}{\mathcal{E}_1}{e_t}
  }{
    \RuleStep{e}{e_1'}
  } \\
  \inferrule[S-Skip]{
    \FInstruct{(\ActStep, \GasOne, 0)}{e}{e_i} \\
    \Decompose{e_i}{\mathcal{E}_0}{e_0} \\
    \Analyze{(\ActStep, 0)}{\mathcal{E}_0}{\mathcal{E}_1}{\ActSkip} \\
    \FTrans{e_0}{e_t} \\
    \Compose{e_1}{\mathcal{E}_1}{e_t} \\
    \RuleStep{e_1}{e_1'}
  }{
    \RuleStep{e}{e_1'}
  } \\
  \text{\hxf{I add a new rule here, so that filters can be properly eliminated.}}\\
  \inferrule[S-Filter]{
    \FInstruct{(\ActStep, \GasOne, 0)}{e}{e_i} \\
    \Decompose{e_i}{\mathcal{E}_0}{\Filter{f}{e_0}} \\
    \Analyze{(\ActStep, 0)}{\mathcal{E}_0}{\mathcal{E}_1}{a} \\
    \FTrans{e_0}{e_t} \\
    \Compose{e_1}{\mathcal{E}_1}{e_t} \\
    \RuleStep{e_1}{e_1'}
  }{
    \RuleStep{e}{e_1'}
  }
\end{mathpar}

% \TODO{hard code defaults instead of making them part of the judgement}

\mck{Does this work with 0-step evaluations e.g. skip \$e in 1 + 2 + 3}

\hxf{After some thought, I think the reason that we can see the result of a 0-step evaluations because we are not reading the result \emph{after} the step. However, we are reading the result of decomposition, not the rules above.}

\hxf{This might also worth making a meta-theory theorem?}

\fbox{\(\FInstruct{(p, a, g, l)}{e}{e'}\)} \(e\) is dynamically instructed to \(e'\).
\begin{mathpar}
  \inferrule[I-V]{
    \Value{v}
  }{
    \FInstruct{(p, a, g, l)}{v}{v}
  } \\
  \inferrule[I-Var-Y]{
    \FPatMatchesExp{p}{x}
  }{
    \FInstruct{(p, a, g, l)}{x}{\Residue{a}{g}{l}{x}}
  } \qquad
  \inferrule[I-Var-N]{
    \FPatNotMatchesExp{p}{x}
  }{
    \FInstruct{(p, a, g, l)}{x}{x}
  } \\
  \inferrule[I-Filter]{
    \FInstruct{(p_0, a_0, g_0, l_0)}{e_0}{e} \\
    \FInstruct{(p, a, g, l_0 + 1)}{e}{e'}
  }{
    \FInstruct{(p_0, a_0, g_0, l_0)}{\Filter{(p, a, g)}{e_0}}{\Filter{(p, a, g)}{e'}}
  } \\
  \inferrule[I-Residue]{
    \FInstruct{(p_0, a_0, g_0, l_0)}{e_0}{e} \\
  }{
    \FInstruct{(p_0, a_0, g_0, l_0)}{\Residue{a}{g}{l}{e_0}}{\Residue{a}{g}{l}{e}}
  } \\
  \inferrule[I-Ap-Y]{
    \FInstruct{(p, a, g, l)}{e_1}{e_1'} \\
    \FInstruct{(p, a, g, l)}{e_2}{e_2'} \\
    \FPatMatchesExp{p}{e_1(e_2)}
  }{
    \FInstruct{(p, a, g, l)}{e_1(e_2)}{\Residue{a}{g}{l}{e_1'(e_2')}}
  } \\
  \inferrule[I-Ap-N]{
    \FInstruct{(p, a, g, l)}{e_1}{e_1'} \\
    \FInstruct{(p, a, g, l)}{e_2}{e_2'} \\
    \FPatNotMatchesExp{p}{e_1(e_2)}
  }{
    \FInstruct{(p, a, g, l)}{e_1(e_2)}{e_1'(e_2')}
  } \\
  \inferrule[I-Add-Y]{
    \FInstruct{(p, a, g, l)}{e_1}{e_1'} \\
    \FInstruct{(p, a, g, l)}{e_2}{e_2'} \\
    \FPatMatchesExp{p}{e_1 + e_2}
  }{
    \FInstruct{(p, a, g, l)}{e_1(e_2)}{\Residue{a}{g}{l}{e_1' + e_2'}}
  } \\
  \inferrule[I-Add-N]{
    \FInstruct{(p, a, g, l)}{e_1}{e_1'} \\
    \FInstruct{(p, a, g, l)}{e_2}{e_2'} \\
    \FPatNotMatchesExp{p}{e_1 + e_2}
  }{
    \FInstruct{(p, a, g, l)}{e_1(e_2)}{e_1' + e_2'}
  }
\end{mathpar}

\mck{I think there's some preservation of priority property to prove here, since the numbers are re-generated on every pass.}

\hxf{I would formalize the preservation property like this: the priority of residue/do statements \emph{produced} by the same filter have the same priorities}

\mck{This instrumentation will regenerate the do statements on every pass - I guess it doesn't cause problems but it would be nice if it didn't?}

\hxf{Yeah it would be much nicer to avoid the duplication of do statements. We can to some ad-hoc fusing of do-statements same effect \& priorties, probably utilmately we want the instrumentation to be Idempotent.}

\fbox{\(\Analyze{(a, l)}{\mathcal{E}}{\mathcal{E}'}{a'}\)} Under the filter environment of \((a, l)\), the context \(\mathcal{E}\) is transitioned to \(\mathcal{E}'\) and the action \(a'\) is returned.
\begin{mathpar}
  \inferrule[A-Var]{
  }{
    \Analyze{(a, l)}{\circ}{\circ}{a}
  } \\
  \inferrule[A-Ap-L]{
    \Analyze{(a, l)}{\mathcal{E}_1}{\mathcal{E}_1'}{a'}
  }{
    \Analyze{(a, l)}{\mathcal{E}_1(e)}{\mathcal{E}_1'(e)}{a'}
  } \qquad
  \inferrule[A-Ap-R]{
    \Analyze{(a, l)}{\mathcal{E}_2}{\mathcal{E}_2'}{a'}
  }{
    \Analyze{(a, l)}{e_1(\mathcal{E}_2)}{e_1(\mathcal{E}_2')}{a'}
  } \\
  \inferrule[A-Add-L]{
    \Analyze{(a, l)}{\mathcal{E}_1}{\mathcal{E}_1'}{a'}
  }{
    \Analyze{(a, l)}{\mathcal{E}_1 + e}{\mathcal{E}_1' + e}{a'}
  } \qquad
  \inferrule[A-Add-R]{
    \Analyze{(a, l)}{\mathcal{E}_2}{\mathcal{E}_2'}{a'}
  }{
    \Analyze{(a, l)}{e_1 + \mathcal{E}_2}{e_1 + \mathcal{E}_2'}{a'}
  } \\
  \inferrule[A-Filter]{
    \Analyze{(a, l)}{\mathcal{E}}{\mathcal{E}'}{a'}
  }{
    \Analyze{(a, l)}{\Filter{(p, a, g)}{\mathcal{E}}}{\Filter{(p, a, g)}{\mathcal{E}'}}{a'}
  } \\
  \inferrule[A-Residue-One-Old]{
    l \le l_0 \\
    \Analyze{(a_0, l_0)}{\mathcal{E}}{\mathcal{E}'}{a'}
  }{
    \Analyze{(a_0, l_0)}{\Residue{a}{\GasOne}{l}{\mathcal{E}}}{\mathcal{E}'}{a'}
  } \\
  \inferrule[A-Residue-One-New]{
    l > l_0 \\
    \Analyze{(a, l)}{\mathcal{E}}{\mathcal{E}'}{a'}
  }{
    \Analyze{(a_0, l_0)}{\Residue{a}{\GasOne}{l}{\mathcal{E}}}{\mathcal{E}'}{a'}
  } \\
  \inferrule[A-Residue-All-Old]{
    l \le l_0 \\
    \Analyze{(a_0, l_0)}{\mathcal{E}}{\mathcal{E}'}{a'}
  }{
    \Analyze{(a_0, l_0)}{\Residue{a}{\GasAll}{l}{\mathcal{E}}}{\Residue{a}{\GasAll}{l}{\mathcal{E}'}}{a'}
  } \\
  \inferrule[A-Residue-All-New]{
    l > l_0 \\
    \Analyze{(a, l)}{\mathcal{E}}{\mathcal{E}'}{a'}
  }{
    \Analyze{(a_0, l_0)}{\Residue{a}{\GasAll}{l}{\mathcal{E}}}{\Residue{a}{\GasAll}{l}{\mathcal{E}'}}{a'}
  }
\end{mathpar}

\fbox{\(\DefCtx \mathcal{E}\)} Context \(\mathcal{E}\).
\[
  \DefCtx \mathcal{E}
  = \FCMark
  \mid \mathcal{E}(d)
  \mid d(\mathcal{E})
  \mid \mathcal{E} + d
  \mid d + \mathcal{E}
  \mid \Filter{(p, a, g)}{l}{\mathcal{E}}
  \mid \Residue{a}{g}{l}{\mathcal{E}}
\]

\fbox{\(\Value e\)} Expression \(e\) is a value.
\begin{mathpar}
  \inferrule[V-Lam]{
  }{
    \Value{\Lam{x}{d}}
  } \qquad
  \inferrule[V-Nat]{
  }{
    \Value{\Nat{n}}
  }
\end{mathpar}

\fbox{\([v / x] e = e'\)} \(e'\) can be obtained by substitution of \(x\) for
\(v\) in expression \(e\).
\[
  \begin{aligned}
    [v / x] \Nat{n} &= \Nat{n} \\
    [v / x] x &= v \\
    [v / x] y &= y && \text{if } x \neq y \\
    [v / x] (e_1(e_2)) &= ([v / x] e_1)([v / x] e_2) \\
    [v / x] (e_1 + e_2) &= ([v / x] e_1) + ([v / x] e_2) \\
    [v / x] \Lam{y}{e} &= \Lam{y}{[v / x] e} && \text{if } x \neq y \\
    [v / x] \Lam{y}{e} &= \Lam{y}{e} && \text{if } x = y \\
    [v / x] \Filter{(p, a, g)}{e} &= \Filter{([v / x]p, a, g)}{[v / x] e} \\
    [v / x] \Residue{a}{g}{l}{e} &= \Residue{a}{g}{l}{[v / x] e} \\
  \end{aligned}
\]

\fbox{\([v / x] p = p'\)} \(p'\) can be obtained by substitution of \(x\) for
\(v\) in pattern \(p\).
\[
  \begin{aligned}
    [v / x] \$e &= \$e \\
    [v / x] \$v &= \$v \\
    [v / x] \Nat{n} &= \Nat{n} \\
    [v / x] y &= y && \text{if } x \neq y \\
    [v / x] (p_1(p_2)) &= ([v / x] p_1)([v / x] p_2) \\
    [v / x] (p_1 + p_2) &= ([v / x] p_1) + ([v / x] p_2) \\
    [v / x] \Lam{y}{e} &= \Lam{y}{[v / x] e} && \text{if } x \neq y \\
    [v / x] \Lam{y}{e} &= \Lam{y}{e} && \text{if } x = y \\
  \end{aligned}
\]

\hxf{Do we use different notation for substitution into patterns}

% \TODO{swap order to [v/x]e}

% \TODO{missing filter and do cases}

% \TODO{missing number literal and addition cases}

% \TODO{use e instead of d everywhere}

% \TODO{substitution into patterns}

% \TODO{fix Lam macro}

% \TODO{combine decompose and recompose?}

% \TODO{add function that removes do one to formalism}

\fbox{\(\Matches{p}{e}\)} means that pattern \(p\) matches expression \(e\).
\begin{mathpar}
  \inferrule[M-All]{\ }{
    \Matches{\$e}{e}
  } \qquad
  \inferrule[M-Val]{\Value{v}}{
    \Matches{\$v}{v}
  } \\
  \inferrule[M-Nat]{
    \
  }{
    \Matches{\Nat{m}}{\Nat{m}}
  }\qquad
  \inferrule[M-Lam]{
    \Lam{x}{e_p} \equiv_{\alpha} \Lam{y}{e_e}
  }{
    \Matches{\Lam{x}{e_p}}{\Lam{y}{e_e}}
  } \\
  \inferrule[M-Ap]{
    \Matches{p_1}{e_1} \\
    \Matches{p_2}{e_2}
  }{
    \Matches{p_1(p_2)}{e_1(e_2)}
  } \qquad
  \inferrule[M-Add]{
    \Matches{p_1}{e_1} \\
    \Matches{p_2}{e_2}
  }{
    \Matches{p_1 + p_2}{e_1 + e_2}
  } \qquad
\end{mathpar}

\mck{M-Lam doesn't allow \$e inside function bodies - is this intentional?}

\hxf{This is not \emph{strictly} intentional, i.e. they can be changed. But I cannot really think of any case that we need to use \$e in function bodies.}

% \mck{It might be clearer if we write out a separate recompose judgement too. I think decompose and recompose behave differently especially with regard to do statements}

\fbox{\(\Decompose{d}{\mathcal{E}}{d'}\)} Expression \(d\) can be obtained by putting expression \(d'\) into the mark of \(\mathcal{E}\).
\begin{mathpar}
  \inferrule[D-Var-E]{
  }{
    \Decompose{x}{\FCMark}{x}
  } \\
  \inferrule[D-Residue-T]{
    \Decompose{e}{\mathcal{E}}{e'}
  }{
    \Decompose{\Residue{a}{g}{l}{e}}{\mathcal{E}}{\Residue{a}{g}{l}{e'}}
  } \\
  \inferrule[D-Residue-E]{
    \Value{v}
  }{
    \Decompose{\Residue{a}{g}{l}{v}}{\circ}{\Residue{a}{g}{l}{v}}
  } \\
  \inferrule[D-Filter-T]{
    \Decompose{e}{\mathcal{E}}{e'}
  }{
    \Decompose{\Filter{f}{e}}{\mathcal{E}}{\Filter{f}{e'}}
  } \\
  \inferrule[D-Filter-E]{
    \Value{v}
  }{
    \Decompose{\Filter{f}{v}}{\circ}{\Filter{f}{v}}
  } \\
  \inferrule[D-Ap-L]{
    \Decompose{e_1}{\mathcal{E}_1}{e_1'}
  }{
    \Decompose{e_1(e_2)}{\mathcal{E}_1(e_2)}{e_1'}
  } \qquad
  \inferrule[D-Ap-R]{
    \Value{e_1} \\
    \Decompose{e_2}{\mathcal{E}_2}{e_2'}
  }{
    \Decompose{e_1(e_2)}{e_1(\mathcal{E}_2)}{e_2'}
  } \qquad
  \inferrule[D-Ap-E]{
    \Value{e_1} \\
    \Value{e_2}
  }{
    \Decompose{e_1(e_2)}{\circ}{e_1(e_2)}
  } \\
  \inferrule[D-Add-L]{
    \Decompose{e_1}{\mathcal{E}_1}{e_1'}
  }{
    \Decompose{e_1 + e_2}{\mathcal{E}_1 + e_2}{e_1'}
  } \qquad
  \inferrule[D-Add-R]{
    \Value{e_1} \\
    \Decompose{e_2}{\mathcal{E}_2}{e_2'}
  }{
    \Decompose{e_1 + e_2}{e_1 + \mathcal{E}_2}{e_2'}
  } \qquad
  \inferrule[D-Add-E]{
    \Value{e_1} \\
    \Value{e_2}
  }{
    \Decompose{e_1 + e_2}{\circ}{e_1 + e_2}
  }
\end{mathpar}
\mck{D-Filter-E rule does not have any filters in it}
\hxf{Now they have!}

\mck{The last four rules seem to specify an evaluation order - is this desired behaviour? I thought we were going to mention the nondeterminism somewhere in the text}

\hxf{Exactly.}

% \mck{Todo: remove the unused `output' g from the above - I think we can also remove the `input` g too?}

% \fbox{\(\Compose{e}{\mathcal{E}}{e'}\)} Expression \(e\) can be obtained by
% putting expression \(e'\) into the mark of \(\mathcal{E}\).
% \begin{mathpar}
%   \inferrule[C-Top]{
%     \
%   }{
%     \Compose{e}{\circ}{e}
%   } \qquad
%   \inferrule[C-Ap-L]{
%     \Compose{e_l}{\mathcal{E}}{e}
%   }{
%     \Compose{e_l(e_r)}{\mathcal{E}(e_r)}{e}
%   } \qquad
%   \inferrule[C-Ap-R]{
%     \Compose{e_r}{\mathcal{E}}{e}
%   }{
%     \Compose{e_l(e_r)}{e_l(\mathcal{E})}{e}
%   } \\
%   \inferrule[C-Add-L]{
%     \Compose{e_l}{\mathcal{E}}{e}
%   }{
%     \Compose{e_l + e_r}{\mathcal{E} + e_r}{e}
%   } \qquad
%   \inferrule[C-Add-R]{
%     \Compose{e_r}{\mathcal{E}}{e}
%   }{
%     \Compose{e_l + e_r}{e_l + \mathcal{E}}{e}
%   } \\
%   \inferrule[C-Filter]{
%     \Compose{e'}{\mathcal{E}}{e}
%   }{
%     \Compose{\Filter{(p, a, g)}{e'}}{\Filter{(p, a, g)}{\mathcal{E}}}{e}
%   } \\
%   \inferrule[C-Residue]{
%     \Compose{e'}{\mathcal{E}}{e}
%   }{
%     \Compose{\Residue{a}{g}{l}{e'}}{\Residue{a}{g}{l}{\mathcal{E}}}{e}
%   }
% \end{mathpar}

% \fbox{\(e_1 \equiv_\alpha e_2\)} \(e_1\) is alpha-equivalent to \(e_2\).
% \begin{mathpar}
%   \inferrule[\(\alpha\)-Var]{
%   }{
%     x \equiv_\alpha x
%   } \qquad
%   \inferrule[\(\alpha\)-Lam]{
%     e_1 \equiv_\alpha [x_2/x_1](e_2)
%   }{
%     \Lam{x_1}{e_1} \equiv_\alpha \Lam{x_2}{e_2}
%   } \\
%   \inferrule[\(\alpha\)-Ap]{
%     e_1 \equiv_\alpha e_3 \\
%     e_2 \equiv_\alpha e_4
%   }{
%     e_1(e_2) \equiv_\alpha e_3(e_4)
%   } \qquad
%   \inferrule[\(\alpha\)-Add]{
%     e_1 \equiv_\alpha e_3 \\
%     e_2 \equiv_\alpha e_4
%   }{
%     e_1 + e_2 \equiv_\alpha e_3 + e_4
%   } \\
%   \inferrule[\(\alpha\)-Filter]{
%     e_1 \equiv_\alpha e_2
%   }{
%     \Filter{(p, a, g)}{e_1} \equiv_\alpha \Filter{(p, a, g)}{e_2}
%   } \\
%   \inferrule[\(\alpha\)-Residue]{
%     e_1 \equiv_\alpha e_2
%   }{
%     \Residue{a}{g}{l}{e_1} \equiv_\alpha \Residue{a}{g}{l}{e_2}
%   }
% \end{mathpar}

\fbox{\(\Strip{e} = {e'}\)} Strip filter/do expression in expression \(e\) to get expression \(e'\).
\[
  \begin{aligned}
    \Strip{x} &= x \\
    \Strip{\Lam{x}{e}} &= \Lam{x}{\Strip{e}} \\
    \Strip{e_1(e_2)} &= (\Strip{e_1})(\Strip{e_2}) \\
    \Strip{\Nat{n}} &= \Strip{\Nat{b}} \\
    \Strip{e_1 + e_2} &= (\Strip{e_1}) + (\Strip{e_2}) \\
    \Strip{\Filter{(p, a, g)}{e}} &= \Strip{e} \\
    \Strip{\Residue{a}{g}{l}{e}} &= \Strip{e}
  \end{aligned}
\]

\fbox{\(\FTrans{e}{e'}\)} \(e\) takes an instruction transition to \(e'\).
\begin{mathpar}
  \inferrule[T-Lam-L]{
    \FTrans{e_1}{e_1'}
  }{
    \FTrans{\Lam{x}{e_1}(e_2)}{\Lam{x}{e_1'}{e_2}}
  } \qquad
  \inferrule[T-Lam-R]{
    \Value{e_1} \\
    \FTrans{e_2}{e_2'}
  }{
    \FTrans{\Lam{x}{e_1}(e_2)}{\Lam{x}{e_1}{e_2'}}
  } \\
  \inferrule[T-Lam-E]{
    \Value{e_1} \\
    \Value{e_2}
  }{
    \FTrans{\Lam{x}{e_1}(e_2)}{\FSubst{e_2}{x}{e_1}}
  } \\
  \inferrule[T-Add-L]{
    \FTrans{e_1}{e_1'}
  }{
    \FTrans{e_1 + e_2}{e_1' + e_2}
  } \qquad
  \inferrule[T-Add-R]{
    \Value{n_1} \\
    \FTrans{e_2}{e_2'}
  }{
    \FTrans{n_1 + e_2}{n_1 + e_2'}
  } \\
  \inferrule[T-Add-E]{
    \Value{n_1} \\
    \Value{n_2} \\
    n_1 + n_2 = n
  }{
    \FTrans{\Nat{n_1} + \Nat{n_2}}{\Nat{n}}
  } \\
  \inferrule[T-Residue-T]{
    \FTrans{e}{e'}
  }{
    \FTrans{\Residue{a}{g}{l}{e}}{\Residue{a}{g}{l}{e'}}
  } \qquad
  \inferrule[T-Residue-E]{
    \Value{v}
  }{
    \FTrans{\Residue{a}{g}{l}{e}}{v}
  } \\
  \inferrule[T-Filter-T]{
    \FTrans{e}{e'}
  }{
    \FTrans{\Filter{f}{e}}{\Filter{f}{e'}}
  } \qquad
  \inferrule[T-Filter-E]{
    \Value{v}
  }{
    \FTrans{\Filter{f}{v}}{v}
  }
\end{mathpar}

\mck{Is FLRes-T redundant since we're using evaluation contexts?}

\hxf{It depends how you treat instruction transition? They are less important than elimination rules}

\mck{ok yeah it would be nice to have a progress property here but I guess we do need types for that...}



\TODO{Properties}
\\\\
Conjecture: Idempotence of Instrumentation (Instrumenting twice should have the same effect as instrumenting once)

$\FInstruct{(p, a, g, l)}{e}{e'} \Rightarrow \FInstruct{(p, a, g, l)}{e'}{e''} \Rightarrow e' = e''$

\mck{This conjecture is actually not true, because instrumentation always adds more do statements, even if they're already there.}
\\\\
Conjecture : Determinism of steps

$\RuleStep{}{}{(a, g)}{e}{e'} \Rightarrow \RuleStep{(a, g)}{e}{e''} \Rightarrow e' = e''$

\mck{I think this holds in this calculus, but not in Hazel itself.}
\\\\
Conjecture(Unchanging Priorities)

???

\mck{Since priorities are always re-numbered, we want some sort of conjecture that they remain the same. We could even possibly use this to avoid duplication of `do's?}
\\\\
Conjecture(Correctness)




\subsection{Statics}

\TODO{Get filter a simple type system like STLC}

\TODO{Gas is not useful in return}

\TODO{Better notation for do's statements}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
