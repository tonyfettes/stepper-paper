\subsection{Definitions}

\TODO{Discuss: do we need to specify the substitution here?}

\fbox{\(\DefAct a\)} Action \(a\) of a filter
\[
  \DefAct a \Coloneqq \FASkip \mid \FAStep
\]

\fbox{\(\DefGas g\)} Gas \(g\) of a filter.
\[
  \DefGas g \Coloneqq \FGOne \mid \FGAll
\]

\fbox{\(\DefExp d\)} Expression \(d\).
\[
  \DefExp d \Coloneqq x \mid d(d) \mid \Lam{x}{d} \mid d + d \mid \Nat{n} \mid \Filter{p}{a}{g}{d} \mid \Residue{a}{g}{l}{d}
\]


\fbox{\(\DefVal d\)} Value \(v\).
\[
  \DefVal v \Coloneqq \Lam{x}{d} \mid \Nat{n}
\]

\mck{I added a value thing here but we should probably actually define it as a judgement instead.}


\fbox{\(\DefCtx \mathcal{E}\)} Context \(\mathcal{E}\).
\[
  \DefCtx \mathcal{E}
  = \FCMark
  \mid \mathcal{E}(d)
  \mid d(\mathcal{E})
  \mid \mathcal{E} + d
  \mid d + \mathcal{E}
  \mid \Filter{p}{a}{g}{l}{\mathcal{E}}
  \mid \Residue{a}{g}{l}{\mathcal{E}}
\]

\mck{Maybe replace $\Residue{a}{g}{l}{\mathcal{E}}$ with $\Residue{a}{\FGAll}{l}{\mathcal{E}}$ because only $\FGAll$ is possible?}

\fbox{\(\DefPat p\)} Pattern \(p\).
\[
  \DefPat p \Coloneqq \$e \mid \$v \mid x \mid p(p) \mid \Lam{x}{d} \mid \Lam{\$x}{d} \mid p + p \mid \Nat{n}
\]

\mck{The $\lambda \$x. $ form actually isn't necessary because we use alpha-equivalence later.}

\fbox{\(\DefFilter f\)} Filter \(f\).
\[
  \DefFilter f = (p, a, g)
\]

\subsection{Dynamics}

\mck{It might be clearer if we write out a separate recompose judgement too. I think decompose and recompose behave differently especially with regard to do statements}

\fbox{\(\FDecompose{(a, g, l)}{d}{\mathcal{E}}{d'}{(a, g)}\)} Expression \(d\) can be obtained by putting expression \(d'\) into the mark of \(\mathcal{E}\).
\begin{mathpar}
  \inferrule[FC-Var]{
  }{
    \FDecompose{(a, g, l)}{x}{\FCMark}{x}{(a, g)}
  } \\
  \inferrule[FC-Int]{
  }{
  } \\
  \inferrule[FC-Lam]{
  }{
  } \\
  \inferrule[FC-Add]{
  }{
  } \\
  \inferrule[FC-Inst-One-New]{
    \FDecompose{(a, \FGOne, l)}{d}{\mathcal{E}}{d'}{(a', g')} \\
    l > l_0
  }{
    \FDecompose{(a_0, g_0, l_0)}{\Residue{a}{\FGOne}{l}{d}}{\mathcal{E}}{d'}{(a', g')}
  } \\
  \inferrule[FC-Inst-One-Old]{
    \FDecompose{(a_0, g_0, l_0)}{d}{\mathcal{E}}{d'}{(a', g')} \\
    l \leq l_0
  }{
    \FDecompose{(a_0, g_0, l_0)}{\Residue{a}{\FGOne}{l}{d}}{\mathcal{E}}{d'}{(a', g')}
  } \\
  \inferrule[FC-Inst-All-New]{
    \FDecompose{(a, \FGAll, l)}{d}{\mathcal{E}}{d'}{(a', g')} \\
    l > l_0
  }{
    \FDecompose{(a_0, g_0, l_0)}{\Residue{a}{\FGAll}{l}{d}}{\Residue{a}{\FGAll}{l}{\mathcal{E}}}{d'}{(a', g')}
  } \\
  \inferrule[FC-Inst-All-Old]{
    \FDecompose{(a_0, g_0, l_0)}{d}{\mathcal{E}}{d'}{(a', g')} \\
    l \leq l_0
  }{
    \FDecompose{(a_0, g_0, l_0)}{\Residue{a}{\FGAll}{l}{d}}{\Residue{a}{\FGAll}{l}{\mathcal{E}}}{d'}{(a', g')}
  } \\
  \inferrule[FC-Flt]{
    \FDecompose{(a_0, g_0, l_0)}{d}{\mathcal{E}}{d'}{(a', g')}
  }{
    \FDecompose{(a_0, g_0, l_0)}{\Filter{p}{a}{g}{d}}{\Filter{p}{a}{g}{\mathcal{E}}}{d'}{(a', g')}
  } \\
  \inferrule[FC-Ap-L]{
    \FDecompose{(a, g, l)}{d_1}{\mathcal{E}_1}{d_1'}{(a_1', g_1')}
  }{
    \FDecompose{(a, g, l)}{d_1(d_2)}{\mathcal{E}_1(d_2)}{d_1'}{(a_1', g_1')}
  } \qquad
  \inferrule[FC-Ap-R]{
    \FValue{d_1} \\
    \FDecompose{(a, g, l)}{d_2}{\mathcal{E}_2}{d_2'}{(a_2', g_2')}
  }{
    \FDecompose{(a, g, l)}{d_1(d_2)}{d_1(\mathcal{E}_2)}{d_2'}{(a_2', g_2')}
  } \\
  \inferrule[FC-Add-L]{
    \FDecompose{(a, g, l)}{d_1}{\mathcal{E}_1}{d_1'}{(a_1', g_1')}
  }{
    \FDecompose{(a, g, l)}{d_1 + d_2}{\mathcal{E}_1 + d_2}{d_1'}{(a_1', g_1')}
  } \qquad
  \inferrule[FC-Add-R]{
    \FValue{d_1} \\
    \FDecompose{(a, g, l)}{d_2}{\mathcal{E}_2}{d_2'}{(a_2', g_2')}
  }{
    \FDecompose{(a, g, l)}{d_1 + d_2}{d_1 + \mathcal{E}_2}{d_2'}{(a_2', g_2')}
  } \\
\end{mathpar}

\mck{The last four rules seem to specify an evaluation order - is this desired behaviour? I thought we were going to mention the nondeterminism somewhere in the text}

\mck{Todo: remove the unused `output' g from the above - I think we can also remove the `input` g too?}

\fbox{\(\FPatMatchesExp{p}{d}\)} means that pattern \(p\) matches expression \(d\).
\begin{mathpar}
  \inferrule[FPME-Ap]{
    \FPatMatchesExp{p_1}{d_1} \\
    \FPatMatchesExp{p_2}{d_2}
  }{
    \FPatMatchesExp{p_1(p_2)}{d_1(d_2)}
  } \qquad
  \inferrule[FPME-Add]{
    \FPatMatchesExp{p_1}{d_1} \\
    \FPatMatchesExp{p_2}{d_2}
  }{
    \FPatMatchesExp{p_1 + p_2}{d_1 + d_2}
  } \qquad
  \inferrule[FPME-Lam]{
    \Lam{x}{d_p} \equiv_{\alpha} \Lam{y}{d_p'}\\
    \FPatMatchesExp{d_p'}{d_d}
  }{
    \FPatMatchesExp{\Lam{x}{d_p}}{\Lam{y}{d_d}}
  } \\
  \inferrule[FPME-Var]{
    x = y
  }{
    \FPatMatchesExp{x}{y}
  }\qquad
  \inferrule[FPME-Nat]{
    m = n
  }{
    \FPatMatchesExp{\Nat{m}}{\Nat{n}}
  }\qquad
  \inferrule[FPME-Expr]{\ }{
    \FPatMatchesExp{\$e}{d}
  } \qquad
  \inferrule[FPME-Value]{\FValue{d}}{
    \FPatMatchesExp{\$v}{d}
  }
\end{mathpar}

% \fbox{\(\FPatMatchesCtx{f}{\mathcal{E}}{d}\)} Pattern \(f\) matches \(\mathcal{E}\) and \(d\).
% \begin{mathpar}
%   \inferrule[FMC-Mark]{
%     \FPatMatchesExp{p}{d}
%   }{
%     \FPatMatchesCtx{p}{\FCMark}{d}
%   } \\
%   \inferrule[FMC-App-L-Y]{
%     \FPatMatchesExp{p}{d_1}
%   }{
%     \FPatMatchesCtx{p}{\mathcal{E}_1(d_2)}{d_1}
%   } \qquad
%   \inferrule[FMC-App-L-N]{
%     \FPatMatchesCtx{p}{\mathcal{E}_1}{d_1}
%   }{
%     \FPatMatchesCtx{p}{\mathcal{E}_1(d_2)}{d_1}
%   } \\
%   \inferrule[FMC-App-R-Y]{
%     \FPatMatchesExp{p}{d_1}
%   }{
%     \FPatMatchesCtx{p}{d_1(\mathcal{E}_2)}{d_1}
%   } \qquad
%   \inferrule[FMC-App-R-N]{
%     \FPatMatchesCtx{p}{\mathcal{E}_2}{d_2}
%   }{
%     \FPatMatchesCtx{p}{d_1(\mathcal{E}_2)}{d_2}
%   }
% \end{mathpar}

\fbox{\(\FInstruct{(p, a, g, l)}{d}{d'}\)} \(d\) is dynamically instructed to \(d'\).
\begin{mathpar}
  \inferrule[FI-V]{
    \FValue{d}
  }{
    \FInstruct{(p, a, g, l)}{d}{d}
  } \\
  \inferrule[FI-Var-Y]{
    \FPatMatchesExp{p}{x}
  }{
    \FInstruct{(p, a, g, l)}{x}{\Residue{a}{g}{l}{x}}
  } \qquad
  \inferrule[FI-Var-N]{
    \FPatNotMatchesExp{p}{x}
  }{
    \FInstruct{(p, a, g, l)}{x}{x}
  } \\
  \inferrule[FI-I]{
    \FInstruct{(p_0, a_0, g_0, l_0)}{d_0}{d} \\
    \FInstruct{(p, a, g, l_0 + 1)}{d}{d'}
  }{
    \FInstruct{(p_0, a_0, g_0, l_0)}{\Filter{p}{a}{g}{d_0}}{\Filter{p}{a}{g}{d'}}
  } \\
  \inferrule[FI-T]{
    \FInstruct{(p_0, a_0, g_0, l_0)}{d_0}{d} \\
  }{
    \FInstruct{(p_0, a_0, g_0, l_0)}{\Residue{a}{g}{l}{d_0}}{\Residue{a}{g}{l}{d'}}
  } \\
  \text{\mck{Why are there `all's in the below instead of `a'?}}\\
  \inferrule[FI-Ap-Y]{
    \FInstruct{(p, a, \FGAll, l)}{d_1}{d_1'} \\
    \FInstruct{(p, a, \FGAll, l)}{d_2}{d_2'} \\
    \FPatMatchesExp{p}{d_1(d_2)}
  }{
    \FInstruct{(p, a, g, l)}{d_1(d_2)}{\Residue{a}{\FGAll}{l}{d_1'(d_2')}}
  } \\
  \inferrule[FI-Ap-N]{
    \FInstruct{(p, a, g, l)}{d_1}{d_1'} \\
    \FInstruct{(p, a, g, l)}{d_2}{d_2'} \\
    \FPatNotMatchesExp{p}{d_1(d_2)}
  }{
    \FInstruct{(p, a, g, l)}{d_1(d_2)}{d_1'(d_2')}
  } \\
  \text{\mck{Why are there `all's in the below instead of `a'?}}\\
  \inferrule[FI-Add-Y]{
    \FInstruct{(p, a, \FGAll, l)}{d_1}{d_1'} \\
    \FInstruct{(p, a, \FGAll, l)}{d_2}{d_2'} \\
    \FPatMatchesExp{p}{d_1 + d_2}
  }{
    \FInstruct{(p, a, g, l)}{d_1(d_2)}{\Residue{a}{\FGAll}{l}{d_1' + d_2'}}
  } \\
  \inferrule[FI-Add-N]{
    \FInstruct{(p, a, g, l)}{d_1}{d_1'} \\
    \FInstruct{(p, a, g, l)}{d_2}{d_2'} \\
    \FPatNotMatchesExp{p}{d_1 + d_2}
  }{
    \FInstruct{(p, a, g, l)}{d_1(d_2)}{d_1' + d_2'}
  }
\end{mathpar}

\mck{I think there's some preservation of priority property to prove here, since the numbers are re-generated on every pass.}

\mck{This instrumentation will regenerate the do statements on every pass - I guess it doesn't cause problems but it would be nice if it didn't?}

\fbox{\(\FTrans{d}{d'}\)} \(d\) takes an transition to \(d'\).
\begin{mathpar}
  \inferrule[FTLam]{
    \FValue{d_2}
  }{
    \FTrans{\Lam{x}{d_1}(d_2)}{\FSubst{d_2}{x}{d_1}}
  } \\
  \inferrule[FTNat]{
    n_1 + n_2 = n
  }{
    \FTrans{\Nat{n_1} + \Nat{n_2}}{\Nat{n}}
  } \\
  \text{\mck{Is FLRes-T redundant since we're using evaluation contexts?}}\\
  \inferrule[FLRes-T]{
    \FTrans{d}{d'}
  }{
    \FTrans{\Residue{a}{g}{d}}{\Residue{a}{g}{d'}}
  } \\
  \inferrule[\textcolor{red}{FLRes-Inst}]{
    \FValue{v}
  }{
    \FTrans{\Residue{a}{g}{l}{d}}{v}
  } \qquad
  \inferrule[\textcolor{red}{FLRes-Filter}]{
    \FValue{v}
  }{
    \FTrans{\Filter{a}{g}{d}}{v}
  }
\end{mathpar}



\mck{ok yeah it would be nice to have a progress property here but I guess we do need types for that...}

\fbox{\(\FStep{(a, g)}{d}{d'}\)} Expression \(d\) steps to expression \(d'\).
\begin{mathpar}
  \inferrule[FS-Step]{
    \FInstruct{(a, g, 0)}{d}{d_i} \\
    \FDecompose{(a, g)}{d_i}{\mathcal{E}}{d_0}{(\FAStep, g_0)} \\
    \FTrans{d_0}{d_0'} \\
    \FCompose{d'}{\mathcal{E}}{d_0'}
  }{
    \FStep{(p, a, g)}{d}{d'}
  } \\
  \inferrule[FS-Skip]{
    \FInstruct{(a, g, 0)}{d}{d_i} \\
    \FDecompose{(a, g)}{d_i}{\mathcal{E}}{d_0}{(\FASkip, g_0)} \\
    \FTrans{d_0}{d_0'} \\
    \FCompose{d'}{\mathcal{E}}{d_0'} \\
    \FStep{(a, g)}{d'}{d''}
  }{
    \FStep{(a, g)}{d}{d''}
  }
\end{mathpar}

\mck{Does this work with 0-step evaluations e.g. skip \$e in 1 + 2 + 3}

\TODO{Properties}
\\\\
Conjecture: Idempotence of Instrumentation (Instrumenting twice should have the same effect as instrumenting once)

$\FInstruct{(p, a, g, l)}{d}{d'} \Rightarrow \FInstruct{(p, a, g, l)}{d'}{d''} \Rightarrow d' = d''$

\mck{This conjecture is actually not true, because instrumentation always adds more do statements, even if they're already there.}
\\\\
Conjecture : Determinism of steps

$\FStep{(a, g)}{d}{d'} \Rightarrow \FStep{(a, g)}{d}{d''} \Rightarrow d' = d''$

\mck{I think this holds in this calculus, but not in Hazel itself.}
\\\\
Conjecture(Unchanging Priorities)

???

\mck{Since priorities are always re-numbered, we want some sort of conjecture that they remain the same. We could even possibly use this to avoid duplication of `do's?}
\\\\
Conjecture(Correctness)




\subsection{Statics}

\TODO{Get filter a simple type system like STLC}

\TODO{Gas is not useful in return}

\TODO{Better notation for do's statements}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
